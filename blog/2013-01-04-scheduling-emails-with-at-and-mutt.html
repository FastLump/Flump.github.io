<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Brian Buccola">
  <title>Scheduling Emails with at and mutt - Brian Buccola</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../style.css">
  <!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
  <meta name="description" content="Brian Buccola's personal blog">
  <meta name="keywords" content="Brian Buccola,linguistics,McGill University">
  <link rel="icon" href="/favicon.png">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Mono:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css">
  
  <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38439922-1']);
      _gaq.push(['_trackPageview']);
  
      (function() {
       var ga = document.createElement('script');
       ga.type = 'text/javascript';
       ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0];
       s.parentNode.insertBefore(ga, s);
       })();
  </script>
</head>
<body>
<!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
<h1 class="blog_title">Brian Buccola</h1>
<h4 class="blog_subtitle">logic, language, linux</h4>

<a class="return_to_index" href="../index.html">Back to index</a>
<h1 class="post_title">Scheduling Emails with at and mutt</h1>
<p class="date">January 04, 2013</p>

<!-- begin metadata
title: Scheduling Emails with at and mutt
date: 2013-01-04 11:08
categories: 
- linux
- mutt
- command line
- scripts
- bash
- howto
end metadata -->

<p>I had assumed that most modern email services, like Gmail, allow users to schedule emails to be sent at some later specified time, but a quick Google search reveals that that’s not quite the case. It looks like you need to use a browser extension like <a href="http://www.boomeranggmail.com/">Boomerang</a> or <a href="http://www.rightinbox.com/">Right Inbox</a>.</p>
<p>But what if you don’t trust browser extensions/third parties to handle private emails? Or what if you don’t use Firefox, Chrome, etc.? (I use <a href="http://portix.bitbucket.org/dwb/">dwb</a>.) In this post I’ll explain how Linux users who are already set up with <a href="http://www.mutt.org/">mutt</a> (or any mail client with similar command-line capability) can harness the powers of <code>at</code> and <code>mutt</code> to schedule emails.</p>
<p>The <code>at</code> command lets you schedule tasks (shell commands) that are to be executed at a specified time. The basic syntax is <code>at TIMESPEC</code>, where timespec is something like <code>now + 10 minutes</code>, <code>noon tomorrow</code>, <code>11:59pm Dec 31</code>, etc. The <code>at</code> command is run from a terminal, and once you specify the timespec and hit enter, you’re put into an interactive prompt where you list the commands that you want <code>at</code> to execute at the specified time. Hit <code>&lt;Ctrl-D&gt;</code> to finish, or <code>&lt;Ctrl-C&gt;</code> to cancel. For example:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">at</span> now + 1 minute
<span class="kw">warning</span>: commands will be executed using /bin/sh
<span class="kw">at&gt;</span> echo <span class="st">&quot;testing out at&quot;</span> <span class="kw">&gt;&gt;</span>~/my-at-test
<span class="kw">at&gt;</span> <span class="kw">&lt;</span>EOT<span class="kw">&gt;</span>
<span class="kw">job</span> 13 at Fri Jan  4 11:46:00 2013</code></pre>
<p>In the above code, we tell <code>at</code> that 1 minute from now, it should append the text “testing out at” to the file <code>my-at-test</code> (and create it if it doesn’t already exist).<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<p>You can run <code>atq</code> to view the queue of current jobs, <code>atrm JOBID</code> to remove a job, and <code>at -c JOBID</code> to view (<strong>c</strong>at) a queued job.</p>
<p>Since <code>at</code> accepts any shell command, we can schedule emails using mutt’s command-line interface. The basic syntax for sending emails with mutt from the command line is</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> <span class="st">&quot;MSG&quot;</span> <span class="kw">|</span> <span class="kw">mutt</span> -s SUBJ -- RECIPIENT <span class="co"># for simple messages</span>
$ <span class="kw">mutt</span> -s SUBJ -- RECIPIENT <span class="kw">&lt;</span>MSG         <span class="co"># for longer messages (files)</span></code></pre>
<p>Suppose I want to email myself a reminder tomorrow at 10am to call John. Here’s what I do.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">at</span> 10am tomorrow
<span class="kw">warning</span>: commands will be executed using /bin/sh
<span class="kw">at&gt;</span> echo <span class="st">&quot;Remember to call John.&quot;</span> <span class="kw">|</span> <span class="kw">mutt</span> -s <span class="st">&quot;Call John&quot;</span> -- me
<span class="kw">at&gt;</span> <span class="kw">&lt;</span>EOT<span class="kw">&gt;</span>
<span class="kw">job</span> 14 at Sat Jan  5 10:00:00 2013</code></pre>
<p>There’s a problem though. If my computer is off tomorrow at 10am, nothing will happen. And if my computer is on but not connected to the internet, then the job will technically be executed (and thus be subsequently removed from the queue), but no mail will be sent.</p>
<p>Moreover, if my computer is off tomorrow at 10am, then <code>at</code> will execute the command the next time I boot, but unfortunately it’ll do so immediately, before enough time has passed to allow my wifi connection to be established.</p>
<p>There’s really no complete remedy to these problems except to ensure that the computer is on and connected to the internet at the specified time (which is no problem for people who rarely turn off their computers, or for dedicated servers).</p>
<p>But if the computer is off and/or not online, there is still a way to ensure that the email is not sent until a wifi connection is established. We just need to write a simple shell script, <code>check-wifi.sh</code>, which only exits once a wifi connection is established.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash</span>

<span class="kw">until [[</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$(</span><span class="kw">iwgetid</span><span class="ot">)</span><span class="st">&quot;</span><span class="kw"> ]]</span>; <span class="kw">do</span>
    <span class="kw">sleep</span> 1
<span class="kw">done</span>

<span class="kw">exit</span> 0</code></pre>
<p><code>iwgetid</code> is a command that returns the ESSID of the current wifi connection if there is one, and nothing otherwise. So this script does the following: keep waiting (sleeping) until <code>iwgetid</code> returns a string of nonzero length, then exit with status 0. (Remember to make it executable: <code>chmod a+x check-wifi.sh</code>.)</p>
<p>Now we can modify our <code>at</code> commands as follows:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">at</span> 10am tomorrow
<span class="kw">at&gt;</span> /path/to/check-wifi.sh
<span class="kw">at&gt;</span> echo <span class="st">&quot;Remember to call John.&quot;</span> <span class="kw">|</span> <span class="kw">mutt</span> -s <span class="st">&quot;Call John&quot;</span> -- me
<span class="kw">at&gt;</span> <span class="kw">&lt;</span>EOT<span class="kw">&gt;</span></code></pre>
<p>Now the email won’t try to be delivered until <code>check-wifi.sh</code> finishes running, i.e., until a wifi connection is established.</p>
<p>We can also modify <code>check-wifi.sh</code> to time out after, say, 3 minutes of no wifi, and to write something to a log file.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash</span>

<span class="ot">COUNT=</span>0
<span class="ot">TIMEOUT=</span>180
<span class="ot">E_TIMEOUT=</span>70

<span class="kw">until [[</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$(</span><span class="kw">iwgetid</span><span class="ot">)</span><span class="st">&quot;</span><span class="kw"> ]]</span>; <span class="kw">do</span>
    <span class="kw">sleep</span> 1
    <span class="kw">let</span> <span class="st">&quot;COUNT+=1&quot;</span>
    <span class="co"># wait $TIMEOUT seconds, then exit</span>
    <span class="kw">if [[</span> <span class="ot">$COUNT</span> <span class="ot">-ge</span> <span class="ot">$TIMEOUT</span><span class="kw"> ]]</span>; <span class="kw">then</span>
        <span class="kw">echo</span> <span class="st">&quot;</span><span class="ot">$(</span><span class="kw">date</span> <span class="st">&#39;+%F %T&#39;</span><span class="ot">)</span><span class="st"> \</span>
<span class="st">            Wifi connection not established. No mail sent.&quot;</span> <span class="kw">&gt;&gt;</span>~/.at.log
        <span class="kw">exit</span> <span class="ot">$E_TIMEOUT</span>
    <span class="kw">fi</span>
<span class="kw">done</span>

<span class="kw">exit</span> 0</code></pre>
<p>The result of all this is that I can schedule an email for, say, 6am tomorrow, when my computer is probably off, and it’ll get delivered the moment I boot up and connect to the internet. Or I can schedule a birthday email for 6am on John’s birthday, and it’ll get sent the moment I boot up and get online, assuming I do so on John’s birthday.</p>
<p>As you can see, the possibilities with <code>at</code>, mutt, and shell scripting are endless.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>at</code> comes with a daemon, <code>atd</code>, which must be running in order to schedule and execute commands. If you get the error</p>
<pre><code>Can&#39;t open /var/run/atd.pid to signal atd. No atd running?</code></pre>
<p>then it means <code>atd</code> is not running. Either run <code>sudo atd</code> to run <code>atd</code> just this once, or do whatever is necessary to have <code>atd</code> load on boot. (In Arch Linux: <code>sudo systemctl enable atd.service</code>.)<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>I have <code>me</code> aliased to my email address in <code>~/.mutt/alias</code>, which is sourced in <code>.muttrc</code>.<a href="#fnref2">↩</a></p></li>
</ol>
</section>
<!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
<hr class="footer"/>
<p class="footer">
<a rel="license" target="_blank"
href="http://creativecommons.org/licenses/by/3.0/">
<img alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br>
2012-2013 &ndash; Brian Buccola<br>
Powered by
    <a target="_blank" href="http://johnmacfarlane.net/pandoc/">Pandoc</a>,
    <a target="_blank" href="http://www.gnu.org/software/bash/">Bash</a>, and
    <a target="_blank" href="https://github.com/">GitHub</a>.
Source code available
    <a target="_blank" href="https://github.com/brianbuccola/brianbuccola.github.io">here</a>.
</p>
</body>
</html>
