<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Brian Buccola">
  <title>Implementing lists in the simply typed lambda calculus - Brian Buccola</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../style.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
  <meta name="description" content="Brian Buccola's personal blog">
  <meta name="keywords" content="Brian Buccola,linguistics,McGill University">
  <link rel="icon" href="/">
  <link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=PT+Mono:400,700,400italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css">
  
  <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38439922-1']);
      _gaq.push(['_trackPageview']);
  
      (function() {
       var ga = document.createElement('script');
       ga.type = 'text/javascript';
       ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0];
       s.parentNode.insertBefore(ga, s);
       })();
  </script>
</head>
<body>
<!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
<h1 class="blog_title">Brian Buccola</h1>
<h4 class="blog_subtitle">logic, language, linux</h4>

<a class="return_to_index" href="../index.html">Back to index</a>
<h1 class="post_title">Implementing lists in the simply typed lambda calculus</h1>
<p class="date">April 22, 2013</p>
<!-- begin metadata
title: Implementing lists in the simply typed lambda calculus
date: 2013-04-22 11:09
end metadata -->
<p>One of my goals this summer is to re-read Bob Carpenter’s <em>Type-Logical Grammar</em> and to actually do (at least some of) the exercises. If I manage to follow through with that goal, I’ll write up my solutions (or attempts at solutions) to some of the more interesting or difficult exercises. I’ll start that off with the last exercise from Chapter 2, which says to add to the simply typed lambda calculus the type <span class="math">\(\sigma^*\)</span> for lists of objects of type <span class="math">\(\sigma\)</span>. First, let me review Chapter 2 to set the stage.</p>
<h2 id="review">Review</h2>
<p>Chapter 2 deals with the syntax, semantics, and proof theory of the simply typed lambda calculus. I’ll review here the syntax and semantics, but not the proof theory.</p>
<h3 id="syntax">Syntax</h3>
<p>Carpenter builds up the set <span class="math">\(\mathbf{Typ}\)</span> of types inductively from a set <span class="math">\(\mathbf{BasTyp}\)</span> of <em>basic types</em>, using just one type constructor: <span class="math">\(\to\)</span>.</p>
<p><strong>Definition (types).</strong> The set of <em>types</em> is the smallest set <span class="math">\(\mathbf{Typ}\)</span> such that</p>
<ol type="1">
<li><span class="math">\(\mathbf{BasTyp} \subseteq \mathbf{Typ}\)</span>.</li>
<li>If <span class="math">\(\sigma, \tau \in \mathbf{Typ}\)</span>, then <span class="math">\((\sigma \to \tau) \in  \mathbf{Typ}\)</span>.</li>
</ol>
<p>A type of the form <span class="math">\((\sigma \to \tau)\)</span> is called a <em>functional type</em>.</p>
<p>For each type <span class="math">\(\tau\)</span>, there is a set <span class="math">\(\mathbf{Var}_\tau\)</span> of variables of type <span class="math">\(\tau\)</span> and a set <span class="math">\(\mathbf{Con}_\tau\)</span> of constants of type <span class="math">\(\tau\)</span>. The set of lambda terms of type <span class="math">\(\tau\)</span> is defined as follows.</p>
<p><strong>Definition (terms).</strong> The set of <em>(lambda) terms</em> of type <span class="math">\(\tau\)</span> is the smallest set <span class="math">\(\mathbf{Term}_\tau\)</span> such that</p>
<ol type="1">
<li><span class="math">\(\mathbf{Var}_\tau \subseteq \mathbf{Term}_\tau\)</span>.</li>
<li><span class="math">\(\mathbf{Con_\tau} \subseteq \mathbf{Term}_\tau\)</span>.</li>
<li>If <span class="math">\(\alpha \in \mathbf{Term}_{\sigma \to \tau}\)</span> and <span class="math">\(\beta \in  \mathbf{Term}_\sigma\)</span>, then <span class="math">\((\alpha(\beta)) \in \mathbf{Term}_\tau\)</span>.</li>
<li>If <span class="math">\(\tau = \sigma \to \rho\)</span> and <span class="math">\(x \in \mathbf{Var}_\sigma\)</span> and <span class="math">\(\alpha \in  \mathbf{Term}_\rho\)</span>, then <span class="math">\(\lambda x . (\alpha) \in \mathbf{Term}_\tau\)</span>.</li>
</ol>
<p>A term of the form <span class="math">\((\alpha(\beta))\)</span>, usually abbreviated <span class="math">\(\alpha(\beta)\)</span> or <span class="math">\(\alpha\ \beta\)</span>, is a <em>functional application</em> of <span class="math">\(\alpha\)</span> to <span class="math">\(\beta\)</span>. However, a term <span class="math">\(\alpha\)</span> with a functional type <span class="math">\((\sigma \to \tau)\)</span> is not a function per se—<span class="math">\(\alpha(\beta)\)</span> is (the result of) a <em>syntactic</em> operation more akin to term concatenation than functional application. Nevertheless, <span class="math">\(\alpha\)</span> is called functional (it has a functional type) because of how it is <em>interpreted semantically</em> (model theoretically).</p>
<h3 id="semantics">Semantics</h3>
<p>In the model theory, functional terms denote functions in the normal mathematical sense. Before defining denotations, I need to define frames and models.</p>
<p><strong>Definition (frame).</strong> A <em>frame</em> for the set <span class="math">\(\mathbf{BasTyp}\)</span> is a collection <span class="math">\(\mathbf{Dom} = \bigcup\mathbf{Dom}_\tau\)</span> (<span class="math">\(\tau \in \mathbf{BasTyp}\)</span>) of <em>basic domains</em>.</p>
<p><strong>Definition (model).</strong> A <em>model</em> is a pair <span class="math">\(\langle \mathbf{Dom},I \rangle\)</span> in which <span class="math">\(\mathbf{Dom}\)</span> is a frame, and <span class="math">\(I\)</span> is the <em>interpretation function</em> mapping constants to the appropriate domain, i.e. <span class="math">\(I(\alpha) \in \mathbf{Dom}_\tau\)</span> if <span class="math">\(\alpha \in \textbf{Con}_\tau\)</span>.</p>
<p><strong>Definition (denotation).</strong> Given a model <span class="math">\(\mathcal{M} = \langle \textbf{Dom}, I \rangle\)</span> and a variable assignment <span class="math">\(\theta\)</span>, the <em>denotation</em> <span class="math">\([\![\alpha]\!]^\theta_\mathcal{M}\)</span> of a term <span class="math">\(\alpha\)</span> with respect to <span class="math">\(\mathcal{M}\)</span> and <span class="math">\(\theta\)</span> is given by:</p>
<ol type="1">
<li>If <span class="math">\(\alpha \in \mathbf{Var}_\tau\)</span>, then <span class="math">\([\![\alpha]\!]^\theta_\mathcal{M} =  \theta(\alpha)\)</span>.</li>
<li>If <span class="math">\(\alpha \in \mathbf{Con}_\tau\)</span>, then <span class="math">\([\![\alpha]\!]^\theta_\mathcal{M} =  I(\alpha)\)</span>.</li>
<li><span class="math">\([\![\alpha(\beta)]\!]^\theta_\mathcal{M} =  [\![\alpha]\!]^\theta_\mathcal{M} ([\![\beta]\!]^\theta_\mathcal{M}]\!])\)</span>, assuming <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> are appropriately typed.</li>
<li><span class="math">\([\![\lambda x . \alpha]\!]^\theta_\mathcal{M} = f\)</span> such that <span class="math">\(f(a) =  [\![\alpha]\!]^{\theta[x:=a]}_\mathcal{M}\)</span>, where <span class="math">\(\theta[x:=a]\)</span> is that variable assignment <span class="math">\(\theta&#39;\)</span> such that <span class="math">\(\theta&#39;(x) = a\)</span> and <span class="math">\(\theta&#39;(y) =  \theta(y)\)</span> for each <span class="math">\(y \neq x\)</span>.</li>
</ol>
<p>Note that the left-hand side of the equality statement in (3) involves term concatenation (function<em>al</em> application), whereas the right-hand side involves real function application in the strict sense.</p>
<p>In other words, <span class="math">\(\alpha\)</span> of type <span class="math">\((\sigma \to \tau)\)</span> is a lambda term whose denotation is a function that maps (elements of the domain of) <span class="math">\(\sigma\)</span>-type things to (elements of the domain of) <span class="math">\(\tau\)</span>-type things.</p>
<p>Carpenter goes on to give the usual axioms for the simply typed lamda calculus (<span class="math">\(\alpha\)</span>-, <span class="math">\(\beta\)</span>-, and <span class="math">\(\eta\)</span>-reduction schemata) and the usual rules of inference (reflexivity, transitivity, congruence, and equivalence) and to prove that the resulting system is both sound and complete.</p>
<h3 id="product-and-sum-types">Product and Sum Types</h3>
<p>The latter part of the chapter adds product and sum types to the system. Product types allow functional terms to take multiple arguments at one time (in a certain sense), while sum types introduce functional terms that can act polymorphically.</p>
<h2 id="exercise-list-types">Exercise: List Types</h2>
<p>Let me now turn to the actual exercise.</p>
<blockquote>
<p>Consider adding <span class="math">\(\sigma^*\)</span> for lists of objects of type <span class="math">\(\sigma\)</span>. What would the terms look like in this scheme and how are they interpreted and treated proof-theoretically? Is there any gain in expressive power by admitting arbitrary lists? What might we do to interpret infinite sequences?</p>
</blockquote>
<p>In this post, I’ll only address the first two questions: what do list terms look like, and how are they interpreted. For my answer, I’ll be borrowing from the functional programming language Haskell.</p>
<h3 id="lists-in-haskell">Lists in Haskell</h3>
<p>In Haskell, lists are things like <code>[3, 5, 0]</code>, <code>[&quot;hello&quot;, &quot;world&quot;]</code>, etc. The order of list elements is important, and list elements can repeat. In that sense, lists are more like tuples (sequences) than sets, except that whereas a tuple (both in Haskell and in Carpenter’s section on product types) can contain objects of all different types, list elements must all be of the <em>same</em> type. For example, in Haskell, <code>(3, &quot;hello&quot;)</code> is a possible pair, consisting of an integer and a string, but <code>[3, &quot;hello&quot;]</code> is not a possible list.</p>
<p>In Haskell, the list type is written as <code>[a]</code>, where <code>a</code> is any type. For example, <code>[3, 5, 0]</code> has type <code>[Int]</code>, while <code>[&quot;hello&quot;, &quot;world&quot;]</code> has type <code>[String]</code>. (NB: In Haskell a string is itself a list of characters, i.e. <code>String</code> is just a type synonym for <code>[Char]</code>.)</p>
<p>Note that Haskell overloads the symbols <code>[]</code>: they are used to construct both terms (Haskell expressions) and types.</p>
<p>I’ll follow Haskell’s lead by writing <span class="math">\([\sigma]\)</span> instead of Carpenter’s <span class="math">\(\sigma^*\)</span> for the type of lists containing <span class="math">\(\sigma\)</span>-type objects, and I’ll similarly overload the symbols <span class="math">\([\ ]\)</span>.</p>
<h3 id="syntax-1">Syntax</h3>
<p>I begin by adding <span class="math">\([\sigma]\)</span> to <span class="math">\(\mathbf{Typ}\)</span>. I do so by adding the following clause to the definition of types:</p>
<ol start="3" type="1">
<li>If <span class="math">\(\sigma \in \mathbf{Typ}\)</span>, then <span class="math">\([\sigma] \in \mathbf{Typ}\)</span>.</li>
</ol>
<p>So <span class="math">\([\ ]\)</span> is a unary type constructor (it takes a single type and returns a new type), whereas <span class="math">\(\to\)</span> is a binary type constructor (it takes two types and returns a new type).</p>
<p>As for terms, I assume that for each list type <span class="math">\(\tau = [\sigma]\)</span> there is a set <span class="math">\(\mathbf{Var}_\tau\)</span> of variables of type <span class="math">\(\tau\)</span> and a set <span class="math">\(\mathbf{Con}_\tau\)</span> of constants of type <span class="math">\(\tau\)</span>. We now need a way to construct arbitrary list terms (similar to how abstraction lets us construct functional terms).</p>
<h4 id="haskell-detour">Haskell Detour</h4>
<p>In Haskell, there are two list constructors: <code>[]</code>, or <em>nil</em> (the empty list), and <code>(:)</code>, or <em>cons</em>. The cons operator has the following type signature:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre>
<p>This means it takes something of type <code>a</code> and something of type <code>[a]</code> and returns something of type <code>[a]</code>. More precisely, it takes an <code>a</code>-type object—call it <code>x</code>— and a list of <code>a</code>-type objects—call it <code>list</code>—and it returns a new list, <code>list'</code>, whose elements are <code>x</code> followed by the elements of <code>list</code>. In other words, cons prepends its first argument (an object of type <code>a</code>) to the beginning of its second argument (a list of objects of type <code>a</code>). (Of course, in Haskell a pure function always returns a new object; it doesn’t modify objects given as arguments, so cons does not <em>literally</em> prepend anything to a given list, unlike, say, <code>list.insert(0, x)</code> in Python.)</p>
<p>For example, to construct a list of integers (objects of type <code>Int</code>), we start with <code>[]</code> of type <code>[Int]</code>, and using <code>(:)</code> we add to the front of <code>[]</code> an integer like <code>0</code> to obtain <code>(:) 0 []</code>, or using infix notation, <code>0 : []</code>. The result is of type <code>[Int]</code> and is normally written as <code>[0]</code>, which hides the cons operator. From <code>[0]</code> we can obtain <code>5 : [0]</code>, written <code>[5, 0]</code>, and from that we can obtain <code>3 : [5, 0]</code>, or <code>[3, 5, 0]</code>, and so on.</p>
<p>More generally, <code>[x1, x2, ..., xN]</code> is syntactic sugar for <code>x1 : ( x2 : ( ... ( xN : [] ) ... ) )</code>.</p>
<h4 id="back-to-terms">Back to Terms</h4>
<p>Returning to our lambda terms, we want, for each type <span class="math">\(\sigma\)</span>, a nil term <span class="math">\([\
]\)</span> of type <span class="math">\([\sigma]\)</span>, and a term constructor for adding an object of type <span class="math">\(\sigma\)</span> to a list of type <span class="math">\([\sigma]\)</span> to produce a new such list. I do so by adding the following clauses to the definition of the set <span class="math">\(\mathbf{Term}_\tau\)</span> of terms of type <span class="math">\(\tau\)</span>.</p>
<ol start="5" type="1">
<li>If <span class="math">\(\tau = [\sigma]\)</span>, then <span class="math">\([\ ] \in \mathbf{Term}_\tau\)</span>.</li>
<li>If <span class="math">\(\tau = [\sigma]\)</span> and <span class="math">\(\alpha \in \mathbf{Term}_\sigma\)</span> and <span class="math">\(\beta \in  \mathbf{Term}_\tau\)</span>, then <span class="math">\((\alpha : \beta) \in \mathbf{Term}_\tau\)</span>.</li>
</ol>
<p>Like functional application, <span class="math">\(:\)</span> is a binary term contructor: it takes two terms to produce a new term.</p>
<p>Following Haskell, I make the following conventions:</p>
<ul>
<li><span class="math">\([\alpha] =_\mbox{def} (\alpha : [\ ])\)</span>.</li>
<li><span class="math">\([\alpha, \beta, \dots] =_\mbox{def} (\alpha : [\beta, \dots])\)</span>.</li>
</ul>
<p>The latter schema can be applied recursively for any list of arbitrary length. For example</p>
<p><span class="math">\[
\begin{align}
[3, 5, 0] &amp;= (3 : [5, 0])           \\
          &amp;= (3 : (5 : [0]))        \\
          &amp;= (3 : (5 : (0 : [\ ])))
\end{align}
\]</span></p>
<p>Since there is a one-to-one correspondence between <span class="math">\([\alpha, \beta, \dots, \gamma]\)</span>-looking things and <span class="math">\((\alpha : (\beta : (\dots (\gamma : [\ ]) \dots)))\)</span>-looking things, one might wonder if we can instead reformulate (6) as follows (in two steps).</p>
<ol start="6" type="1">
<li>If <span class="math">\(\tau = [\sigma]\)</span> and <span class="math">\(\alpha \in \mathbf{Term}_\sigma\)</span>, then <span class="math">\([\alpha] \in \mathbf{Term}_\tau\)</span>.</li>
<li>If <span class="math">\(\tau = [\sigma]\)</span> and <span class="math">\(\alpha \in \mathbf{Term}_\sigma\)</span> and <span class="math">\([\beta] \in  \mathbf{Term}_\tau\)</span>, then <span class="math">\([\alpha, \beta] \in \mathbf{Term}_\tau\)</span>.</li>
</ol>
<p>(In other words, we can construct a singleton list from a single object, and a 2-element list from two objects.)</p>
<p>The problem is that (7) cannot be applied recursively. For example, from <span class="math">\(0\)</span> we can obtain <span class="math">\([0]\)</span> by appyling (6), and from <span class="math">\(5\)</span> and <span class="math">\([0]\)</span> we can obtain <span class="math">\([5,0]\)</span> by applying (7). But we cannot apply (7) to, say, <span class="math">\(3\)</span> and <span class="math">\([5,0]\)</span> to obtain <span class="math">\([3,5,0]\)</span> because, although <span class="math">\([5,0]\)</span> is of type <span class="math">\([\sigma]\)</span>, <span class="math">\(5,0\)</span> is not a term of any kind, let alone one of type <span class="math">\(\sigma\)</span>.</p>
<p>For this reason, and for the sake of making cons explicit, I’ll stick with the first formulation of (6) above.</p>
<h3 id="semantics-1">Semantics</h3>
<p>Now that I’ve added list types and list terms to the syntax, I need to add their denotations to the model theory, and this is where I’m a bit stuck, primarily because there are several options and I don’t know which is best/normal, or which one Carpenter has in mind.</p>
<p>If <span class="math">\(\alpha\)</span> is of a list type, say <span class="math">\([\sigma]\)</span>, then the denotation of <span class="math">\(\alpha\)</span> is in <span class="math">\(\mathbf{Dom}_{[\sigma]}\)</span>, but what precisely is the structure of <span class="math">\(\mathbf{Dom}_{[\sigma]}\)</span>?</p>
<p>For example, functional terms denote functions, so the denotation of <span class="math">\(\alpha\)</span> of type <span class="math">\((\sigma \to \tau)\)</span> is a member of <span class="math">\(\mathbf{Dom}_{\tau}^{\mathbf{Dom}_\sigma}\)</span>, i.e. a function from <span class="math">\(\mathbf{Dom}_\sigma\)</span> to <span class="math">\(\mathbf{Dom}_\tau\)</span>. Product terms denote pairs (and more generally, tuples), so the denotation of <span class="math">\(\langle \alpha, \beta \rangle\)</span> of type <span class="math">\(\sigma \times \tau\)</span> is a member of <span class="math">\(\mathbf{Dom}_\sigma \times \mathbf{Dom}_\tau\)</span>. But what does/should a list <span class="math">\(\alpha\)</span> of type <span class="math">\([\sigma]\)</span> denote, set theoretically? A flat set, i.e. a member of the power set of <span class="math">\(\mathbf{Dom}_\sigma\)</span>? Probably not, because sets don’t care about order or repetition, whereas lists (as I’ve defined them) do. What about tuples, i.e. members of <span class="math">\(\mathbf{Dom}_\sigma \times \dots \times \mathbf{Dom}_\sigma\)</span>? Maybe, but product terms already do that. Something else? I’m not sure.</p>
<p>A concrete example might help decide. Suppose we have the type <span class="math">\(\mathbf{Ind}\)</span> for individuals and that <span class="math">\(\mathbf{john}, \mathbf{bill}, \mathbf{sue} \in \mathbf{Term}_\mathbf{Ind}\)</span>. Then we can create a list of these individuals, <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{sue}]\)</span>, which is of type <span class="math">\([\mathbf{Ind}]\)</span>. Suppose also that in some model <span class="math">\(\mathcal{M}\)</span>, <span class="math">\(\mathbf{john}\)</span> denotes <span class="math">\(j\)</span>, <span class="math">\(\mathbf{bill}\)</span> denotes <span class="math">\(b\)</span>, and <span class="math">\(\mathbf{sue}\)</span> denotes <span class="math">\(s\)</span>, where <span class="math">\(j,b,s \in \mathbf{Dom}_\mathbf{Ind}\)</span>. Then what should the list of these three individuals denote? Probably <em>not</em> the flat set <span class="math">\(\{j,b,s\} \in \mbox{Pow}(\mathbf{Dom}_\mathbf{Ind})\)</span>, because then <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{sue}]\)</span> and <span class="math">\([\mathbf{bill}, \mathbf{john}, \mathbf{sue}]\)</span> and <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{bill}, \mathbf{sue}]\)</span> would all denote the same set (at least if we apply the most obvious denotation mapping), which is probably undesirable. One reason for introducing lists in the first place is, I assume, so they can serve as meaning representations for natural language expressions that care about order and repetition.</p>
<p>Assuming, then, that we want these three lists to denote different things, the only reasonable possibility I can think of is to map lists to tuples. For example, <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{sue}]\)</span> will denote <span class="math">\(\langle j,b,s \rangle\)</span>, which is an element of <span class="math">\(\mathbf{Ind} \times \mathbf{Ind} \times \mathbf{Ind}\)</span>. In this way, list terms are essentially like product terms, but with two main differences: (i) both products and lists denote tuples, but lists are composed of objects of the <em>same</em> type, meaning that the tuples they denote will contain objects from the <em>same</em> domain; and (ii) empty and singleton lists are possible, whereas empty and singleton tuples are in general (at least for Carpenter) not, as far as I can tell.</p>
<p>The following clauses get added to the definition of denotation.</p>
<ol start="5" type="1">
<li>If <span class="math">\(\tau = [\sigma]\)</span> and <span class="math">\(\alpha = [\ ] \in \mathbf{Term}_\tau\)</span>, then <span class="math">\([\![\alpha]\!]^\theta_\mathcal{M} = \emptyset\)</span>.</li>
<li><span class="math">\([\![(\alpha : \beta)]\!]^\theta_\mathcal{M} = \langle  [\![\alpha]\!]^\theta_\mathcal{M}, [\![\beta]\!]^\theta_\beta \rangle\)</span>, assuming <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> are appropriately typed.</li>
</ol>
<p>Continuing the example above, <span class="math">\([\mathbf{john}] = (\mathbf{john} : [\ ])\)</span> denotes <span class="math">\(\langle j, \emptyset \rangle \in \mathbf{Dom}_\mathbf{[Ind]}\)</span>. And <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{sue}]\)</span> denotes <span class="math">\(\langle j, \langle b, \langle s,\emptyset \rangle \rangle \rangle \in \mathbf{Dom}_\mathbf{[Ind]}\)</span>. Rewriting tuples in the usual way (analogous to lists above), where <span class="math">\(\langle a,b,c, \dots \rangle =_\mbox{def} \langle a, \langle b,c, \dots \rangle \rangle\)</span>, the latter denotation becomes <span class="math">\(\langle j,b,s,\emptyset \rangle\)</span>.</p>
<p>So what is the structure of <span class="math">\(\mathbf{Dom}_\mathbf{[Ind]}\)</span>? It’s a set whose members are tuples, of varying size, consisting of individuals (except the last tuple member, which is always <span class="math">\(\emptyset\)</span> except in the case of the empty tuple).</p>
<p>More generally, <span class="math">\(\mathbf{Dom}_{[\sigma]}\)</span> is a set whose members are tuples, of varying size, consisting of elements from <span class="math">\(\mathbf{Dom}_\sigma\)</span>.</p>
<p>This is different from the case of products: the domain of intepretation for, say, a pair of terms <span class="math">\(\langle \alpha,\beta \rangle\)</span> is <span class="math">\(\mathbf{Dom}_\sigma \times \mathbf{Dom}_\tau\)</span>, which contains only pairs, not tuples of any other size; and the domain of interpretation for, say, a triple of terms <span class="math">\(\langle \alpha,\beta,\gamma \rangle\)</span> is <span class="math">\(\mathbf{Dom}_\sigma \times \mathbf{Dom}_\tau \times \mathbf{Dom}_\rho\)</span>, which contains only triples, not tuples of any other size. Hence, whereas, say, <span class="math">\([\alpha, \beta]\)</span> and <span class="math">\([\alpha, \beta, \gamma]\)</span> have denotations in the same domain, <span class="math">\(\langle \alpha,\beta \rangle\)</span> and <span class="math">\(\langle \alpha,\beta,\gamma \rangle\)</span> do not.</p>
<p>I’ll conclude by mentioning that it’s kind of weird to use <span class="math">\(\emptyset\)</span> in the denotation of lists, but this is necessary because the denotation function is a total function, and since the empty list, <span class="math">\([\ ]\)</span>, is a term, it requires a denotation. If <span class="math">\([\ ]\)</span> is of type <span class="math">\([\sigma]\)</span>, it doesn’t make sense for its denotation to include anything from <span class="math">\(\mathbf{Dom}_\sigma\)</span>, so we’re stuck with having it denote something like <span class="math">\(\emptyset\)</span>.</p>
<p>One way to avoid this would be to redefine lists: empty lists are simply not possible terms (objects). The smallest list would then be a singleton list, which would denote a <span class="math">\(1\)</span>-tuple, so <span class="math">\([\mathbf{john}]\)</span> would denote <span class="math">\(\langle j \rangle\)</span> rather than <span class="math">\(\langle j,\emptyset \rangle\)</span>, and <span class="math">\([\mathbf{john}, \mathbf{bill}, \mathbf{sue}]\)</span> would denote <span class="math">\(\langle j,b,s \rangle\)</span> rather than <span class="math">\(\langle j,b,s,\emptyset \rangle\)</span>.</p>
<!-- Warning: Do not edit this file; it will be overwritten during blog rebuild. -->
<hr class="footer"/>
<p class="footer">
<a rel="license" target="_blank"
href="http://creativecommons.org/licenses/by/3.0/">
<img alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br>
2012-2015 &ndash; Brian Buccola<br>
Powered by
    <a target="_blank" href="http://johnmacfarlane.net/pandoc/">Pandoc</a>,
    <a target="_blank" href="http://www.gnu.org/software/bash/">Bash</a>, and
    <a target="_blank" href="https://github.com/">GitHub</a>.
Source code available
    <a target="_blank" href="https://github.com/brianbuccola/brianbuccola.github.io">here</a>.
</p>
</body>
</html>
